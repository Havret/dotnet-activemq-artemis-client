"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[305],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>g});var a=t(6540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(t),m=r,g=p["".concat(c,".").concat(m)]||p[m]||d[m]||s;return t?a.createElement(g,o(o({ref:n},u),{},{components:t})):a.createElement(g,o({ref:n},u))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,o=new Array(s);o[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[p]="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},823:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(8168),r=t(8587),s=(t(6540),t(5680)),o=["components"],i={id:"transactions",title:"Transactions",sidebar_label:"Transactions"},c=void 0,l={unversionedId:"transactions",id:"transactions",title:"Transactions",description:"ActiveMQ Artemis provides several guarantees regarding reliable message delivery and processing. In Message Durability Modes section, you may learn how to send a single message so it won't be lost in transit.",source:"@site/../docs/transactions.md",sourceDirName:".",slug:"/transactions",permalink:"/dotnet-activemq-artemis-client/docs/transactions",draft:!1,editUrl:"https://github.com/Havret/dotnet-activemq-artemis-client/edit/master/website/../docs/transactions.md",tags:[],version:"current",frontMatter:{id:"transactions",title:"Transactions",sidebar_label:"Transactions"},sidebar:"someSidebar",previous:{title:"Automatic Recovery",permalink:"/dotnet-activemq-artemis-client/docs/auto-recovery"},next:{title:"Messaging Model",permalink:"/dotnet-activemq-artemis-client/docs/messaging-model"}},u={},p=[],d={toc:p},m="wrapper";function g(e){var n=e.components,t=(0,r.A)(e,o);return(0,s.yg)(m,(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"ActiveMQ Artemis provides several guarantees regarding reliable message delivery and processing. In ",(0,s.yg)("a",{parentName:"p",href:"/dotnet-activemq-artemis-client/docs/message-durability"},"Message Durability Modes")," section, you may learn how to send a single message so it won't be lost in transit."),(0,s.yg)("p",null,"If you need stronger guarantees that span over multiple messages you need to use transactions."),(0,s.yg)("p",null,"Let's image that as part of your processing flow you want to send a series of messages in a all or nothing manner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-csharp"},'var connectionFactory = new ConnectionFactory();\nvar endpoint = Endpoint.Create("localhost", 5672, "guest", "guest");\nvar connection = await connectionFactory.CreateAsync(endpoint);\n\nawait using (var transaction = new Transaction())\n{\n    await producer.SendAsync(\n        address: "credit-queue",\n        message: new Message("credit:500,account:a"),\n        transaction: transaction\n    );\n    await producer.SendAsync(\n        address: "debit-queue",\n        message: new Message("debit:500,account:b"),\n        transaction: transaction);\n\n    await transaction.CommitAsync();\n}\n')),(0,s.yg)("p",null,"Consumers attached to ",(0,s.yg)("inlineCode",{parentName:"p"},"credit-queue")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"debit-queue")," won't see any messages until you call ",(0,s.yg)("inlineCode",{parentName:"p"},"CommitAsync")," on the ",(0,s.yg)("inlineCode",{parentName:"p"},"Transaction")," object. If any of these operations fail, it will be as if nothing happened. "),(0,s.yg)("p",null,"Message acknowledge operations can also participate in a transaction. The typical flow is that you receive a message ","[1]",", do some transformation, and publish another message ","[2]"," as a result. In order to be sure that the ","[1]"," will be acknowledged only if you successfully sent the ","[2]",", you can do sth like this:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-csharp"},'var endpoint = Endpoint.Create("localhost", 5672, "guest", "guest");\nvar connectionFactory = new ConnectionFactory();\nawait using var connection = await connectionFactory.CreateAsync(endpoint);\nawait using var producer = await connection.CreateProducerAsync("my-address-2", RoutingType.Anycast);\nawait using var consumer = await connection.CreateConsumerAsync("my-address-1", RoutingType.Anycast);\n\nvar msg1 = await consumer.ReceiveAsync();\n\nawait using (var transaction = new Transaction())\n{\n    // transactionally acknowledge message\n    await consumer.AcceptAsync(msg1, transaction);\n\n    var result = DoSomeProcessing(msg1);\n    var msg2 = new Message(result);\n\n    // transactionally send another message\n    await producer.SendAsync(msg2, transaction);\n\n    // commit the two operations\n    await transaction.CommitAsync();\n}\n')))}g.isMDXComponent=!0}}]);