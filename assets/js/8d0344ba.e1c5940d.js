"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[218],{1798:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},metadata:function(){return l},toc:function(){return c},default:function(){return d}});var a=t(7462),i=t(3366),s=(t(7294),t(3905)),o=["components"],r={id:"getting-started",title:"Getting started",sidebar_label:"Getting Started"},l={unversionedId:"getting-started",id:"getting-started",isDocsHomePage:!1,title:"Getting started",description:".NET ActiveMQ Artemis Client is a lightweight library built on top of AmqpNetLite. The main goal of this project is to provide a simple API that allows fully leverage Apache ActiveMQ Artemis capabilities in .NET World.",source:"@site/../docs/getting-started.md",sourceDirName:".",slug:"/getting-started",permalink:"/dotnet-activemq-artemis-client/docs/getting-started",editUrl:"https://github.com/Havret/dotnet-activemq-artemis-client/edit/master/website/../docs/getting-started.md",version:"current",sidebar_label:"Getting Started",frontMatter:{id:"getting-started",title:"Getting started",sidebar_label:"Getting Started"},sidebar:"someSidebar",next:{title:"Message payload",permalink:"/dotnet-activemq-artemis-client/docs/message-payload"}},c=[{value:"Installation",id:"installation",children:[]},{value:"API overview",id:"api-overview",children:[]},{value:"Creating a connection",id:"creating-a-connection",children:[]},{value:"Disconnecting",id:"disconnecting",children:[]},{value:"Sending messages",id:"sending-messages",children:[]},{value:"Receiving messages",id:"receiving-messages",children:[]}],p={toc:c};function d(e){var n=e.components,t=(0,i.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,".NET ActiveMQ Artemis Client is a lightweight library built on top of ",(0,s.kt)("a",{parentName:"p",href:"http://azure.github.io/amqpnetlite/"},"AmqpNetLite"),". The main goal of this project is to provide a simple API that allows fully leverage Apache ActiveMQ Artemis capabilities in .NET World."),(0,s.kt)("h2",{id:"installation"},"Installation"),(0,s.kt)("p",null,".NET ActiveMQ Artemis Client is distributed via ",(0,s.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/ArtemisNetClient"},"NuGet"),". You can add ActiveMQ.Artemis.Client NuGet package using dotnet CLI:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"dotnet add package ArtemisNetClient\n")),(0,s.kt)("h2",{id:"api-overview"},"API overview"),(0,s.kt)("p",null,"The API interfaces and classes are defined in the ",(0,s.kt)("inlineCode",{parentName:"p"},"ActiveMQ.Artemis.Client")," namespace:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},"using ActiveMQ.Artemis.Client;\n")),(0,s.kt)("p",null,"The core API interfaces and classes are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"IConnection")," : represents AMQP 1.0 connection"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ConnectionFactory")," : constructs IConnection instances"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"IConsumer")," : represents a message consumer"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"IProducer")," : represents a message producer attached to a specified ",(0,s.kt)("em",{parentName:"li"},"address")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"IAnonymousProducer")," : represents a message producer capable of sending messages to multiple ",(0,s.kt)("em",{parentName:"li"},"addresses"))),(0,s.kt)("h2",{id:"creating-a-connection"},"Creating a connection"),(0,s.kt)("p",null,"Before any message can be sent or received, a connection to the broker endpoint has to be opened. The AMQP endpoint where the client connects is represented as an ",(0,s.kt)("inlineCode",{parentName:"p"},"Endpoint")," object. The ",(0,s.kt)("inlineCode",{parentName:"p"},"Endpoint")," object can be created using the factory method ",(0,s.kt)("inlineCode",{parentName:"p"},"Create")," that accepts individual parameters specifying different parts of the Uri."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'Endpoint.Create(\n    host: "localhost",\n    port: 5672,\n    user: "guest",\n    password: "guest",\n    scheme: Scheme.Amqp);\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"host")," and the ",(0,s.kt)("inlineCode",{parentName:"li"},"port")," parameters define TCP endpoint."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"user")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"password")," parameters determine if authentication (AMQP SASL)  should be performed after the transport is established. When ",(0,s.kt)("inlineCode",{parentName:"li"},"user")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"password")," are absent, the library skips SASL negotiation altogether. "),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"scheme")," parameter defines if a secure channel (TLS/SSL) should be established.")),(0,s.kt)("p",null,"To open a connection to an ActiveMQ Artemis node, first instantiate a ",(0,s.kt)("inlineCode",{parentName:"p"},"ConnectionFactory")," object. ",(0,s.kt)("inlineCode",{parentName:"p"},"ConnectionFactory")," provides an asynchronous connection creation method that accepts ",(0,s.kt)("inlineCode",{parentName:"p"},"Endpoint")," object."),(0,s.kt)("p",null,"The following snippet connects to an ActiveMQ Artemis node on ",(0,s.kt)("inlineCode",{parentName:"p"},"localhost")," on port ",(0,s.kt)("inlineCode",{parentName:"p"},"5672")," as a ",(0,s.kt)("inlineCode",{parentName:"p"},"guest")," user using ",(0,s.kt)("inlineCode",{parentName:"p"},"guest")," as a password via the insecure channel (AMQP)."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'var connectionFactory = new ConnectionFactory();\nvar endpoint = Endpoint.Create("localhost", 5672, "guest", "guest");\nvar connection = await connectionFactory.CreateAsync(endpoint);\n')),(0,s.kt)("h2",{id:"disconnecting"},"Disconnecting"),(0,s.kt)("p",null,"Closing connection, the same as opening, is a fully asynchronous operation."),(0,s.kt)("p",null,"To disconnect, simply call ",(0,s.kt)("inlineCode",{parentName:"p"},"DisposeAsync")," on connection object:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},"await connection.DisposeAsync();\n")),(0,s.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"important")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Connections, producers, and consumers are meant to be long-lived objects. The underlying protocol is designed and optimized for long-running connections. That means that opening a new connection per operation, e.g. sending a message, is unnecessary and strongly discouraged as it will introduce a lot of network round trips and overhead. The same rule applies to all client resources."))),(0,s.kt)("h2",{id:"sending-messages"},"Sending messages"),(0,s.kt)("p",null,"The client uses ",(0,s.kt)("inlineCode",{parentName:"p"},"IProducer")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"IAnonymousProducer")," interfaces for sending messages. To to create an instance of ",(0,s.kt)("inlineCode",{parentName:"p"},"IProducer")," you need to specify an address name and a routing type to which messages will be sent."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'var producer = await connection.CreateProducerAsync("a1", RoutingType.Anycast);\n')),(0,s.kt)("p",null,"All messages sent using this producer will be automatically routed to address ",(0,s.kt)("inlineCode",{parentName:"p"},"a1")," using ",(0,s.kt)("inlineCode",{parentName:"p"},"Anycast")," routing type:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'await producer.SendAsync(new Message("foo"));\n')),(0,s.kt)("p",null,"To send messages to other addresses you can create more producers or use ",(0,s.kt)("inlineCode",{parentName:"p"},"IAnonymousProducer")," interface. ",(0,s.kt)("inlineCode",{parentName:"p"},"IAnonymousProducer")," is not connected to any particular address."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},"var anonymousProducer = await connection.CreateAnonymousProducer();\n")),(0,s.kt)("p",null,"Each time you want to send a message, you need to specify the address name and the routing type:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'await anonymousProducer.SendAsync("a2", RoutingType.Multicast, new Message("foo"));\n')),(0,s.kt)("h2",{id:"receiving-messages"},"Receiving messages"),(0,s.kt)("p",null,"The client uses ",(0,s.kt)("inlineCode",{parentName:"p"},"IConsumer")," interface for receiving messages. ",(0,s.kt)("inlineCode",{parentName:"p"},"IConsumer")," can be created as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'var consumer = await connection.CreateConsumerAsync("a1", RoutingType.Anycast);\n')),(0,s.kt)("p",null,"As soon as the subscription is set up, the messages will be delivered automatically as they arrive, and then buffered inside consumer object. The number of buffered messages can be controlled by ",(0,s.kt)("inlineCode",{parentName:"p"},"Consumer Credit")," . In order to get a message, simply call ",(0,s.kt)("inlineCode",{parentName:"p"},"ReceiveAsync")," on ",(0,s.kt)("inlineCode",{parentName:"p"},"IConsumer")," ."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},"var message = await consumer.ReceiveAsync();\n")),(0,s.kt)("p",null,"If there are no messages buffered ",(0,s.kt)("inlineCode",{parentName:"p"},"ReceiveAsync")," will asynchronously wait and return as soon as the new message appears on the client."),(0,s.kt)("p",null,"This operation can potentially last an indefinite amount of time (if there are no messages), therefore ",(0,s.kt)("inlineCode",{parentName:"p"},"ReceiveAsync")," accepts ",(0,s.kt)("inlineCode",{parentName:"p"},"CancellationToken")," that can be used to communicate a request for cancellation."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},"var cts = new CancellationTokenSource();\nvar message = await consumer.ReceiveAsync(cts.Token);\n")),(0,s.kt)("p",null,"This may be particularly useful when you want to shut down your application."))}d.isMDXComponent=!0}}]);